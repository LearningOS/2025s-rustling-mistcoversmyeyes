### 🤖 Assistant

### Rust Vec 完全手册（迭代器无关版）

#### 一、基础概念
```rust
// Vec 是堆分配的、可增长的数组类型
let mut vec = Vec::new();       // 空vec
vec.push(1);                    // 追加元素
let v = vec![1, 2, 3];          // 宏初始化
```

#### 二、核心操作分类

##### 1. 创建与初始化
| 方法                 | 作用                          | 示例                        | C++ 近似         |
|----------------------|-------------------------------|----------------------------|------------------|
| `new()`              | 创建空Vec                     | `Vec::new()`               | `vector<>()`     |
| `with_capacity(n)`   | 预分配容量                    | `Vec::with_capacity(10)`   | `vector.reserve` |
| `vec![]`宏           | 字面量初始化                  | `vec![1, 2, 3]`            | 初始化列表        |

##### 2. 元素操作
| 方法                 | 作用                          | 注意事项                    |
|----------------------|-------------------------------|----------------------------|
| `push()`             | 追加元素                      | 可能触发重新分配           |
| `pop()`              | 移除最后一个元素              | 返回Option<T>              |
| `insert(index, val)` | 指定位置插入                  | O(n)时间复杂度             |
| `remove(index)`      | 移除指定位置元素              | 会移动后续元素             |

##### 3. 访问与查询
| 方法                 | 返回类型          | 越界处理          |
|----------------------|-------------------|-------------------|
| `[index]`            | T                 | panic             |
| `get(index)`         | Option<&T>        | 安全访问          |
| `len()`              | usize             | 当前元素数量      |
| `capacity()`         | usize             | 当前分配容量      |

##### 4. 内存管理
```rust
vec.shrink_to_fit();    // 释放多余容量
vec.reserve(10);        // 确保至少10个元素空间
vec.truncate(2);        // 截断到前两个元素
```

#### 三、特殊用例模式

##### 1. 批量操作
```rust
let mut vec = vec![1, 2, 3];
vec.extend([4, 5].iter().copied());  // 批量追加
vec.append(&mut vec![6, 7]);         // 转移所有权追加
```

##### 2. 切片操作
```rust
let slice = &vec[1..3];       // 获取不可变切片
let slice_mut = &mut vec[..2];// 获取可变切片
```

##### 3. 类型转换
```rust
// Vec -> 数组（需要长度匹配）
let arr: [i32; 3] = vec.try_into().unwrap(); 

// Vec -> 迭代器（见迭代器手册）
let iter = vec.into_iter();
```

#### 四、性能特性

##### 容量增长策略
- 默认按指数增长（当前长度翻倍）
- 平均时间复杂度：O(1) 分摊的插入成本
- 推荐使用 `with_capacity` 预分配已知大小

##### 内存布局图示
```
[ ptr | cap | len ]
   |
   v
堆内存：[T][T][T][未初始化区域...]
```

#### 五、所有权模式

##### 1. 移动语义
```rust
let v1 = vec![1, 2];
let v2 = v1;          // 所有权转移
// println!("{:?}", v1); // 编译错误
```

##### 2. 借用规则
```rust
let mut vec = vec![1, 2];
let first = &vec[0];   // 不可变借用
// vec.push(3);        // 编译错误！存在活跃借用
```

#### 六、与数组的对比
| 特性         | Vec                      | 数组              |
|--------------|--------------------------|-------------------|
| 大小         | 动态可变                 | 固定              |
| 存储位置     | 堆                       | 栈                |
| 传递方式     | 移动或引用               | 自动拷贝          |
| 性能特征     | 随机访问快，插入删除中等 | 极致快速访问      |

#### 七、常见错误模式

##### 错误1：迭代器失效（已解耦，详见迭代器手册）
```rust
let mut vec = vec![1, 2];
let first = &vec[0];
vec.push(3); // 编译错误：存在活跃借用
```

##### 错误2：越界访问
```rust
let vec = vec![1];
// let x = vec[1];    // 运行时panic
let x = vec.get(1);  // 安全返回None
```

#### 八、实用技巧

##### 模式1：交换删除
```rust
// 高效删除中间元素（不保持顺序）
let idx = 2;
vec.swap_remove(idx); 
```

##### 模式2：条件保留
```rust
// 原地过滤元素（内存高效）
vec.retain(|x| x % 2 == 0);
```

##### 模式3：矩阵存储
```rust
// 二维vec的两种内存布局
let row_major = vec![vec![1,2], vec![3,4]];  // 行主序
let flat = vec![1,2,3,4];                     // 扁平存储
```

官方参考：
- [std::vec::Vec 文档](https://doc.rust-lang.org/std/vec/struct.Vec.html)
- [Rust 内存模型](https://doc.rust-lang.org/nomicon/vec.html)



-----
您观察得非常仔细！虽然我无法直接插入真实图片，但我们可以用纯文本的「ASCII艺术」来创建可视化图示。以下是改进后的Vec手册示例，包含文本图示：

---

### Rust Vec 完全手册（增强图示版）

#### 一、内存布局图示
```rust
let vec = vec![1, 2, 3];

栈内存：
+---------+---------+---------+
| pointer | capacity | length  |
| 0x1234  |    4     |    3    |
+---------+---------+---------+

堆内存（地址 0x1234）：
+-----+-----+-----+-----+
|  1  |  2  |  3  | ??? |
+-----+-----+-----+-----+
         已初始化   未初始化
```

#### 二、容量增长示意图
```text
初始容量：2
操作记录：
push(1) → [1]       (len=1, cap=2)
push(2) → [1,2]     (len=2, cap=2)
push(3) → 触发扩容
+---+---+               +---+---+---+---+
| 1 | 2 | 扩容 →       | 1 | 2 | 3 |   |
+---+---+               +---+---+---+---+
新容量：4
```

#### 三、所有权转移图示
```text
let v1 = vec![🦀, 🐻];
let v2 = v1;

内存变化：
v1的状态：
+---------+---------+---------+
| pointer | capacity | length  |
| 0x0     |    0     |    0    |  (变为空Vec)
+---------+---------+---------+

v2获得所有权：
+---------+---------+---------+
| pointer | capacity | length  |
| 0x5678  |    2     |    2    |
+---------+---------+---------+
```

#### 四、切片操作图示
```text
原始Vec：
索引: 0   1   2   3   4
值: [🍎, 🍐, 🍊, 🍇, 🍓]

获取切片 &v[1..4]:
+---+---+---+
| 🍐 | 🍊 | 🍇 |
+---+---+---+
内存共享，无拷贝
```

#### 五、swap_remove原理
```text
初始状态：
索引: 0   1   2   3
值: [A, B, C, D]

执行 swap_remove(1)：
1. 将索引1与最后一个元素交换 → [A, D, C, B]
2. 移除最后一个元素 → [A, D, C]
```
